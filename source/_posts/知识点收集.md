---
title: 知识点收集
date: 2020-12-28 09:55:38
tags: javascript
---
- 1.作用域
javascript中的作用域是我们可以有效访问变量或函数的区域。JS有三种类型的作用域：**全局作用域**、**函数作用域**、**块作用域**。
- 全局作用域
在全局命名空间中声明的变量或函数位于全局作用域中，因此在代码中的任何地方可以访问他们。
- 函数作用域
在函数中声明的变量、函数、参数可以在函数内部访问，但不能在函数外部访问。
- 块作用域
在块{}中声明的变量(let, const)只能在其中访问。  
作用域也是一组用于查找变量的规则。如果变量在当前作用域中不存在，它将向外部作用域中查找并搜索，如果该变量不存在，它将再次查找直到到达全局作用域，如果找到，则可以使用它，，否则引发错误，这种查找的过程称为**作用域链**
- 2、javascript中的虚值
```javascript
  const falsyValues = ['', false, 0, null, undefined, NaN]
```
虚值就是在转换为布尔值时变为false的值。使用Boolean或者!!来转换
- 3、手动实现Array.prototype.map方法
map()方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后饭后的结果。
```javascript
  function myMap(arr, mapCallback) {
    // 首先，检查传递的参数是否正确
    if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
      return []
    } else {
      let result = []
      // 每次调用此函数是，都会创建一个result数组，不改变原数组
      for (let i = 0, len = arr.length; i < len; i++) {
        // 将mapCallback返回的结果push到result数组中
        result.push(mapCallback(arr[i], i, arr))
      }

      return result
    }
  }
```
- 4、手动实现Array.proptype.filter方法
filter()方法创建一个新数组，其包含通过所提供的函数实现的测试的所有元素
```javascript
  function myFilter(arr, filterCallback) {
    if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
      return []
    } else {
      // 创建新数组，防止改变原数组
      let result = []
      for(let i = 0, len = arr.length; i < len; i++) {
        // 检查filterCallback的返回值是否是真值
        if (filterCallback(arr[i], i, arr)) {
          // 如果条件为真，则将当前元素push到result中
          result.push(arr[i])
        }
      }
    }

    return result
  }
```
- 5、手动实现Array.prototype.reduce方法
reduce()方法对数组中的每个元素执行一个提供的reducer函数（升序执行），将其结果汇总为单个值返回。
```javascript
  function myReduce(arr, reduceCallback, initialValue) {
    if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') {
      return []
    } else {
      // 如果缺少initialValue,使用数组的第一个参数作为initialValue
      const hasInitialValue  = initialValue !== undefined
      let value = hasInitialValue ? initialValue : arr[0]

      // 如果有传递initialValue，则索引从1开始，否则从0开始
      for (let i = hasInitialValue ? 1 : 0, len = arr.length; i < len; i++) {
        value = reduceCallback(value, arr[i], i, arr)
      }

      return value
    }
  }
```
- 6、javascript
javascript = ECMAScript + DOM + BOM
- 7、var VS let VS const
  + 在全局作用域中，var声明的变量，默认绑定在window上，let和const不会
  + var存在变量提升，let和const不会
  + let和const会形成块级作用域，同一个作用域下，let和const不能声明同名变量，var可以；
  + 暂时性死区 const声明的变量，必须要有初始值，并且后续不能更改，如果是复合类型的数据，可以修改其属性。
- 8、JavaScript数组实现交集、并集和查集（ES7/6/5）
  + ES7 新增了一个Array.proptype.includes的数组方法，用于返回一个数组是否包含指定元素，结合fitter方法
```javascript
  const union = a.concat(b.filter(item => !a.includes(item))) // 并集
  const common = a.filter(item => b.includes(item)) // 交集
  const diffence = a.concat(b).filter(item => a.includes(item) && !b.includes(item))
```
   + ES6新增了一个Array.from方法，用于将类数组对象和可遍历对象转化为数组。只要类数组有长度，基本都可以转化为数组。结合Set结构实现数学集求解。
```javascript
  let a = [1, 2, 3]
  let b = [2, 4, 5]
  let aSet = new Set(a)
  let bSet = new Set(b)
  const union = Array.from(new Set(a.concat(b))) || [...new Set(a.concat(b))] // 并集
  const common = Array.from(new Set(a.filter(item => bSet.has(item)))) || [...new Set(a.filter(item => bSet.has(item)))]
  const difference = Array.from(new Set(a.concat(b).filter(item => aSet.has(item) && !bSet.has(item))))
```
  + ES5可以利用filter和indexOf进行数学集操作，但是，由于indexOf方法中NaN永远返回-1，需要进行兼容处理。
```javascript
  // 不考虑NaN
  const a = [1, 2, 3]
  const b = [2, 3, 4]
  const union = a.concat(b.filter(item => a.indexOf(item) === -1))
  const common = a.concat(b.filter(item => a.indexOf(item) > -1))
  const difference = a.filter(item => b.indexOf(item) === -1)

  // 考虑NaN
  const a = [1, 2, 3, NaN]
  const b = [2, 3, 4]

  const aHasNaN = a.some(item => Number.isNaN(item))
  const bHasNaN = b.some(item => Number.isNaN(item))

  // 并集
  const union = a.concat(b.filter(item => a.indexOf(item) === -1 && !Number.isNaN(item))).concat(!aHasNaN && bHasNaN ? [NaN] : [])
  // 交集
  const common = a.concat(b.filter(item => a.indexOf(item) > -1)).concat(aHasNaN && bHasNaN ? [NaN] : [])
  // 差集
  const difference = a.filter(item => b.indexOf(item) === -1 && !Number.isNaN(item)).concat(aHasNaN && !bHasNaN ? [NaN] : [])
```
- 9、什么情况下不使用箭头函数？
  + 当想要箭头函数提升时（箭头函数是匿名的）
  + 要在函数中使用this/arguments时，由于箭头函数本身不具有this/arguments因此它们取决于外部上下文
  + 使用命名函数（箭头函数是匿名的）
  + 使用函数作为构造函数时（箭头函数不能作为构造函数）