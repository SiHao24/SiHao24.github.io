---
title: 创建对象
date: 2020-05-12 22:42:36
tags: javascript 对象
---
使用模式的原因：使用同一个接口创建很多对象。会产生很多重复的代码。
### 6.2.1 工厂模式
抽象了具体对象的过程
<!-- more -->
```javascript
    function createPerson(name, age, job) {
        const o = new Object()
        o.name = name
        o.age = age
        o.job = job
        o.sayName = function () {
            alert(this.name)
        }

        return o
    }

    const person1 = createPerson('Nicholas', 29, 'Software Engineer')
    const person2 = createPerson('Greg', 27, 'Doctor')
```
- 解决了创建多个相似对象的问题，但却没有解决**对象识别的问题**（怎样知道一个对象的类型）
### 6.2.2 构造函数模式
ECMAScript中的构造函数可用来创建特定类型的对象，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。。
```javascript
    function Person(name, age, job) {
        this.name = name
        this.age = age
        this.job = obj
        this.sayName = function () {
            alert(this.name)
        }
    }
    const person1 = new Person('Nicholas', 29, 'Software Engineer')
    const person2 = new Person('Greg', 27, 'Doctor')
```
- 没有显式的创建对象
- 直接将属性和方法赋给了this对象
- 没有return语句
构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。    
使用new操作符实际上会经历以下4个步骤：
- 1.创建一个新对象
- 2.将构造函数的作用域赋给新对象（因此this就指向了这个新对象）
- 3.执行构造函数中的代码（为这个新对象添加属性）
- 4.返回新对象
```javascript
    person1.constructor === Person // true
    person2.constructor === Person // true
```
对象的constructor属性最初是用来标识对象类型的。上面使用new操作符创建的对象（person1、person2）既是Object的实例，也是Person的实例。
```javascript
    person1 instanceof Object // true
    person1 instanceof Person // true
    person2 instanceof Object // true
    person2 instanceof Person // true
```
创建自定义的构造函数意味着将来可以将他的实例标识为一种特定的类型，**正是胜过工厂模式的地方**。以上两个实例之所以同时是Object的实例，是因为**所有对象均继承自Object**
- 将构造函数当作函数
构造函数VS其他函数：**调用方式不同**
```javascript
    // 当做构造函数调用
     const person = new Person('Nicholas', 29, 'Software Engineer')
     person.sayName() // Nicholas

    // 作为普通函数调用
    Person('Greg', 27, 'Doctor')
    window.sayName() // Greg

    // 在另一个对象的作用域中调用
    const o = new Object()
    Person.call(o, 'Kristen', 25, 'Nurse')
    o.sayName() // Kristen
```
构造函数的问题：**每个方法都要在每个实例上重新创建一遍**
person1和person2都有sayName()方法，但是**两个方法不是同一个Function的实例**。ECMAScript中的函数是对象，每定义一个函数，也就是实例化了一个对象。**不同实例上的同名函数实不相等的**。
```javascript
    person1.sayName === person2.sayName // false
```
```javascript
    function Person(name, age, job) {
        this.name = name
        this.age = age
        this.job = job
        this.sayName = sayName
    }

    function sayName() {
        alert(this.name)
    }

    const person1 = new Person('Nicholas', 29, 'Software Engineer')
    const person2 = new Person('Greg', 27, 'Doctor')
```
### 6.2.3 原型模式
创建的每一个函数都有**prototype(原型)**属性，是一个指针，指向一个对象，而这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法。prototype就是通过构造函数而创建的那个实例对象的原型对象。
- 好处
可以让所有对象实例共享它所包含的属性和方法。也就是不必再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。
```javascript
    function Person() {}
    Person.prototype.name = 'Nichloas'
    Person.prototype.age = 29
    Person.prototype.job = 'Software Engineer'
    Person.prototype.sayName = function() {
        alert(this.name)
    }

    const person1 = new Person()
    const person2 = new Person()
    person1.sayName === person2.sayName // true
```
- 理解原型对象
只要创建一个新函数，会根据一定的规则为该函数创建一个**prototype**属性，这个属性指向**函数的原型对象**。默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性。这个属性包含一个指向prototype属性所在函数的指针。例如：Person.prototype.constructor指向Person，而通过这个构造函数，还可以继续为原型对象添加其他的属性和方法。
