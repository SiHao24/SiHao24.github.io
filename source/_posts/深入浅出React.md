---
title: 深入浅出React
date: 2020-11-09 19:48:27
tags: React, React Hook
---
### useEffect():允许函数组件执行副作用操作
useEffect可以接受两个参数，分别是**回调函数**和**依赖数组**
```javascript
  useEffect(callback, [])
```
- 每一次渲染后都执行的副作用：传入回调函数，不传依赖数组
```javascript
  useEffect(callback)
```
- 仅在挂载阶段执行一次的副作用：传入回调函数，**且这个函数的返回值不是一个函数**，同时传入一个空数组
```
  useEffect(() => {}, [])
```
- 仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，**且这个函数的返回值是一个函数**,同时传入一个空数组。假如回调函数本身记为A，返回的函数记为B，那么将在挂载阶段执行A，卸载阶段执行B。
```javascript
  useEffect(() => {
    // 这里是A的业务逻辑
    // 返回一个函数记为B
    return () => {

    }
  }, [])
```
这种调用方式之所以会在卸载阶段去触发B函数的逻辑，是由useEffect的执行规则决定的：**useEffect回调中返回的函数被称为“清除函数”**,，让React识别到清除函数是，会在卸载时执行清除函数内部的逻辑。**这个规律不会受第二个参数或者其他因素的影响，只要在useEffect中返回了一个函数，它就会被作为清除函数来处理**。
- 每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。
```javascript
  useEffect(() => {
    // 这里是A的业务逻辑
    // 返回一个函数记为B

    return () => {

    }
  })
```
- 根据一定的依赖条件来触发副作用：传入回调函数（若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理），同时**传入一个非空的数组**
```javascript
  useEffect(() => {
    // 这是回调函数的业务逻辑
    // 若xxx是一个函数，则xxx会在组件卸载时触发
  }, [num1, num2, num3])
```
数组中的变量一般都是来源于组件本身的数据（props或者state）。如数组不为空，那么React就会在新的一次渲染后去对比前后两次的渲染，查看数组内容是否有变量发生了更新（只要有一个数组元素变了，就会被认为更新发生了），并在有更新的前提下触发useEffect中定义的副作用逻辑。
### Why React Hooks
- 告别难以理解的Class；
- 解决业务逻辑难以拆分的问题；
- 使状态逻辑复用变得简单可行；
- 函数组件从设计思想上来看，更加契合React的理念。
